package com.example.floggy.service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import com.example.floggy.domain.Vulnerability;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
public class VulnerabilityService {
    
    private final WebClient nvdWebClient;
    private final WebClient githubAdvisoryWebClient;
    private final WebClient snykWebClient;
    private final ObjectMapper objectMapper;
    
    @Value("${vulnerability.snyk.api.token:}")
    private String snykApiToken;
    
    @Autowired
    public VulnerabilityService(
            @Qualifier("nvdWebClient") WebClient nvdWebClient,
            @Qualifier("githubAdvisoryWebClient") WebClient githubAdvisoryWebClient,
            @Qualifier("snykWebClient") WebClient snykWebClient,
            ObjectMapper objectMapper) {
        this.nvdWebClient = nvdWebClient;
        this.githubAdvisoryWebClient = githubAdvisoryWebClient;
        this.snykWebClient = snykWebClient;
        this.objectMapper = objectMapper;
    }
    
    public List<Vulnerability> fetchVulnerabilitiesByCpe(String cpeName) {
        try {
            String response = nvdWebClient.get()
                .uri(uriBuilder -> uriBuilder
                    .queryParam("cpeName", cpeName)
                    .queryParam("resultsPerPage", 50)
                    .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();
            
            return parseNvdResponse(response);
        } catch (Exception e) {
            log.error("Failed to fetch vulnerabilities from NVD for CPE {}: {}", cpeName, e.getMessage());
            return new ArrayList<>();
        }
    }
    
    public List<Vulnerability> fetchVulnerabilitiesByPackage(String packageManager, String packageName, String version) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        // Fetch from NVD
        String cpeName = generateCpeName(packageManager, packageName);
        vulnerabilities.addAll(fetchVulnerabilitiesByCpe(cpeName));
        
        // Fetch from GitHub Advisory
        vulnerabilities.addAll(fetchGitHubAdvisories(packageManager, packageName));
        
        // Fetch from Snyk (if token available)
        if (snykApiToken != null && !snykApiToken.isEmpty()) {
            vulnerabilities.addAll(fetchSnykVulnerabilities(packageManager, packageName, version));
        }
        
        return vulnerabilities;
    }
    
    private List<Vulnerability> parseNvdResponse(String response) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            JsonNode root = objectMapper.readTree(response);
            JsonNode vulnerabilitiesNode = root.path("vulnerabilities");
            
            if (vulnerabilitiesNode.isArray()) {
                for (JsonNode vulnNode : vulnerabilitiesNode) {
                    JsonNode cveNode = vulnNode.path("cve");
                    
                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setSource("NVD");
                    vulnerability.setVulnerabilityId(cveNode.path("id").asText());
                    
                    // Get CVSS score
                    JsonNode metrics = cveNode.path("metrics");
                    if (metrics.has("cvssMetricV31")) {
                        JsonNode cvssV31 = metrics.path("cvssMetricV31").get(0);
                        vulnerability.setCvssScore(cvssV31.path("cvssData").path("baseScore").asDouble());
                        vulnerability.setSeverity(mapCvssScoreToSeverity(vulnerability.getCvssScore()));
                    } else if (metrics.has("cvssMetricV30")) {
                        JsonNode cvssV30 = metrics.path("cvssMetricV30").get(0);
                        vulnerability.setCvssScore(cvssV30.path("cvssData").path("baseScore").asDouble());
                        vulnerability.setSeverity(mapCvssScoreToSeverity(vulnerability.getCvssScore()));
                    } else if (metrics.has("cvssMetricV2")) {
                        JsonNode cvssV2 = metrics.path("cvssMetricV2").get(0);
                        vulnerability.setCvssScore(cvssV2.path("cvssData").path("baseScore").asDouble());
                        vulnerability.setSeverity(mapCvssScoreToSeverity(vulnerability.getCvssScore()));
                    }
                    
                    vulnerability.setDescription(cveNode.path("descriptions").get(0).path("value").asText());
                    
                    // Parse dates
                    String published = cveNode.path("published").asText();
                    String lastModified = cveNode.path("lastModified").asText();
                    if (!published.isEmpty()) {
                        vulnerability.setPublishedDate(LocalDateTime.parse(published, DateTimeFormatter.ISO_DATE_TIME));
                    }
                    if (!lastModified.isEmpty()) {
                        vulnerability.setLastModifiedDate(LocalDateTime.parse(lastModified, DateTimeFormatter.ISO_DATE_TIME));
                    }
                    
                    // Get references
                    JsonNode references = cveNode.path("references");
                    StringBuilder refs = new StringBuilder();
                    for (JsonNode ref : references) {
                        refs.append(ref.path("url").asText()).append(";");
                    }
                    vulnerability.setReferences(refs.toString());
                    
                    vulnerabilities.add(vulnerability);
                }
            }
        } catch (Exception e) {
            log.error("Failed to parse NVD response: {}", e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    private List<Vulnerability> fetchGitHubAdvisories(String packageManager, String packageName) {
        try {
            String response = githubAdvisoryWebClient.get()
                .uri(uriBuilder -> uriBuilder
                    .queryParam("package", packageManager + ":" + packageName)
                    .build())
                .retrieve()
                .bodyToMono(String.class)
                .block();
            
            return parseGitHubAdvisoryResponse(response);
        } catch (Exception e) {
            log.error("Failed to fetch GitHub advisories for {}:{}: {}", packageManager, packageName, e.getMessage());
            return new ArrayList<>();
        }
    }
    
    private List<Vulnerability> parseGitHubAdvisoryResponse(String response) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            JsonNode root = objectMapper.readTree(response);
            if (root.isArray()) {
                for (JsonNode advisoryNode : root) {
                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setSource("GitHub Advisory");
                    vulnerability.setVulnerabilityId(advisoryNode.path("ghsa_id").asText());
                    vulnerability.setSeverity(advisoryNode.path("severity").asText().toUpperCase());
                    
                    // Map severity to CVSS score approximation
                    vulnerability.setCvssScore(mapSeverityToCvssScore(vulnerability.getSeverity()));
                    
                    vulnerability.setDescription(advisoryNode.path("summary").asText());
                    vulnerability.setAffectedVersions(advisoryNode.path("vulnerable_version_range").asText());
                    vulnerability.setPatchedVersions(advisoryNode.path("patched_versions").asText());
                    
                    String published = advisoryNode.path("published_at").asText();
                    if (!published.isEmpty()) {
                        vulnerability.setPublishedDate(LocalDateTime.parse(published, DateTimeFormatter.ISO_DATE_TIME));
                    }
                    
                    String updated = advisoryNode.path("updated_at").asText();
                    if (!updated.isEmpty()) {
                        vulnerability.setLastModifiedDate(LocalDateTime.parse(updated, DateTimeFormatter.ISO_DATE_TIME));
                    }
                    
                    vulnerabilities.add(vulnerability);
                }
            }
        } catch (Exception e) {
            log.error("Failed to parse GitHub advisory response: {}", e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    private List<Vulnerability> fetchSnykVulnerabilities(String packageManager, String packageName, String version) {
        try {
            String response = snykWebClient.get()
                .uri("/vuln/{packageManager}/{packageName}/{version}", packageManager, packageName, version)
                .header("Authorization", "token " + snykApiToken)
                .retrieve()
                .bodyToMono(String.class)
                .block();
            
            return parseSnykResponse(response);
        } catch (Exception e) {
            log.error("Failed to fetch Snyk vulnerabilities for {}:{}:{}: {}", packageManager, packageName, version, e.getMessage());
            return new ArrayList<>();
        }
    }
    
    private List<Vulnerability> parseSnykResponse(String response) {
        List<Vulnerability> vulnerabilities = new ArrayList<>();
        
        try {
            JsonNode root = objectMapper.readTree(response);
            JsonNode issues = root.path("issues");
            
            if (issues.isArray()) {
                for (JsonNode issue : issues) {
                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setSource("Snyk");
                    vulnerability.setVulnerabilityId(issue.path("id").asText());
                    vulnerability.setSeverity(issue.path("severity").asText().toUpperCase());
                    vulnerability.setCvssScore(issue.path("cvssScore").asDouble());
                    vulnerability.setDescription(issue.path("title").asText());
                    
                    vulnerabilities.add(vulnerability);
                }
            }
        } catch (Exception e) {
            log.error("Failed to parse Snyk response: {}", e.getMessage());
        }
        
        return vulnerabilities;
    }
    
    private String generateCpeName(String packageManager, String packageName) {
        // Simple CPE generation - in real implementation, this would be more sophisticated
        return "cpe:2.3:a:" + packageName.replace("-", "_") + ":" + packageName + ":*:*:*:*:*:" + packageManager + ":*";
    }
    
    private String mapCvssScoreToSeverity(Double score) {
        if (score == null) return "UNKNOWN";
        if (score >= 9.0) return "CRITICAL";
        if (score >= 7.0) return "HIGH";
        if (score >= 4.0) return "MEDIUM";
        if (score > 0.0) return "LOW";
        return "NONE";
    }
    
    private Double mapSeverityToCvssScore(String severity) {
        switch (severity.toUpperCase()) {
            case "CRITICAL": return 9.5;
            case "HIGH": return 7.5;
            case "MEDIUM": return 5.0;
            case "LOW": return 2.0;
            default: return 0.0;
        }
    }
    
    public Double calculateSecurityScore(List<Vulnerability> vulnerabilities) {
        if (vulnerabilities.isEmpty()) return 100.0;
        
        double totalScore = 0.0;
        int count = 0;
        
        for (Vulnerability vuln : vulnerabilities) {
            if (vuln.getCvssScore() != null) {
                totalScore += vuln.getCvssScore();
                count++;
            }
        }
        
        if (count == 0) return 100.0;
        
        double averageCvss = totalScore / count;
        // Convert to 0-100 scale where 0 CVSS = 100 score, 10 CVSS = 0 score
        return Math.max(0, 100 - (averageCvss * 10));
    }
}